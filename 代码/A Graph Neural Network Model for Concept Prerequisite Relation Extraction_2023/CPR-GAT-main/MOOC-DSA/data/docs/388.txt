Hello everybody, welcome back to our Flows in Networks unit. Today we're actually going to, finally, give an algorithm to compute maximum flows. So the idea of this algorithm is very much along the lines that we've been sort of hinting at the entire time. We're going to start with zero flow, in our network, so the trivial flow, no flow along any edge. And we're going to repeatedly add a tiny bit of flow, sort of building up the flow a little bit at a time, until we reach a state where it's impossible to add anymore flow, and then we'll be done. So how do we add flow? You have some flow f. We then compute the residual network, Gf. And this really does represent the ways in which flow can be added. So any new flow that we would have would be of the form f + g, where g is a flow in our residual network. So if we want to replace f by a slightly larger flow, all we need is a slightly positive flow in the residual network. And to do that, all we want to do is see if there's a source to sink path in this network. So, what happens if there's no path? If there's no source to sink path in our residual network, then the set of vertices that we can reach from the source defines a cut of size 0. That says there's no flow in the residual of positive size. And so any flow f + g has size at most the size of f and f is a maximum flow. And so if that's the case, we're done. We already have a maximum flow and we can just stop. Now if there is a path, it turns out we can always add flow along that path. What you do is if you add x units of flow to each edge along that path, well, you have conservation of flow, there's x units in an x units out of each vertex on that path. And as long as x is at most the minimum capacity of any of these edges in the residual graph, this is actually a flow in the residual network. So if we do this, we find some flow g for our residual network with the size of g is bigger than 0. Then we'll replace f by f + g, we found a new flow where the size of f + g is strictly bigger than the size of f. We found flow that's slightly bigger than the one we had before. So to make this formal, we produced what's known as the Ford-Fulkerson algorithm for max flow. You start by letting f be the trivial flow. And then you repeat the following. You compute the residual graph for f. You then try and find an s to t path, P, in this residual graph. If there is no such path, we know that we already have a max flow so we can just return f. Otherwise, what we're going to do is we're going to let X be the minimum capacity of any edge along this path in the residual network. We're going to let g be a flow, where g assigns X units of flow to each edge along this path. And then we're going to let f be f + g. And when we do this we increased out flow by a little bit and we just keep repeating until we can't increase our flow anymore. So, for example, we've got the network here. Here's our residual network. How much flow do we end up adding in one step? Well to figure this out you have to do two things. You first have to find your S to T path, which is this one. And then you say, well how much capacity are there on the edges? Which edge has minimum capacity? And that's this edge of capacity 4. And so in this case you'd route four units of flow on your first step. But, to really see how this algorithm works let's take the following example. So, we have a graph up top. Initially we have no flow running through that graph so the graph below is the residual, is the same network that we started with. And now what we want to do is we want to find paths in the residual network. So here's an S to T path. The minimum capacity along this path is 5, so we route 5 units of flow along each of these edges. Now this updates the residual, we have a couple, we've got a new edge, we got an edge that wasn't there before, whatever. We now want to again find an S to T path in the residual graph. This one works out pretty well. Again, the minimum capacity of these edges is 5, so we route 5 more units of flow along each of those edges and we update the residual graph again. Once again, we find an S to T path in the residual graph. This one works pretty well. The minimum capacity here on these edges is 2. So we route 2 more units of flow along each of those edges. And, at this point, once we've updated the residual we will note there is no S to T path. In fact, there's a cut right here that prevents us from routing any more flow. And so given that cut you can actually see that this flow which routes 12 total units of flow is actually a maximum flow and so we're done. So before we get into analyzing the run time of this algorithm, there's an important point to make. We should note that if all the capacities that we have are integers in our original network, then all the flows that we produce are also integer. Because every time we try and augment our flow along some path, we look at the smallest capacity, which is always an integer. And so we put an integer amount of flow everywhere and everything remains integer if we started with integers. And there's an interesting lemma that we get out of this, which actually will prove useful to us later, that says if you have a network G with integer capacities, there's always a maximum flow with integer flow rates. And you can get it just by using the Ford-Fulkerson algorithm. Okay but now let's look at the analysis. And for this analysis to work I'm going to have to assume that all capacities are integers. Now what does this algorithm do? Every time through this loop, we compute the residual graph and then we try to find a path P in it. And each of these run in O of number of edges time. Now, every time we do that, we increase the total flow by a little bit, in fact by at least 1. So the number of times we do it is most the total flow on our graph. So our total runtime is bounded by the number of edges in our graph times the size of the maximum flow. Now this is a little bit weird as a runtime, because it depends not just on sort of the structure of the graph that we're working on, but also the capacities of the edges and the size of the maximum flow. This leads us to a problem, where, potentially at least, if we have numerically very, very large capacities in our graph, it could actually take us a very, very long time to compute the flow. One other thing I should note about this algorithm is that it's not quite a full algorithm. What it says is at every step I need to find some source to sink path in our residual. Now, there might be many valid paths to choose from, and the Ford-Fulkerson algorithm, as I've stated, doesn't really tell you which one to use. Now you might just want to run depth-first search because it's very fast, but maybe that's not the best way to do it. And as we'll see a little bit later in fact, finding the right way to pick these augmenting paths can actually have a substantial impact on the runtime of the algorithm. But that's for a little bit later. That's all for our lecture today. Next time, we'll talk a little bit more about the runtime of this particular algorithm. So I hope to see you then. 