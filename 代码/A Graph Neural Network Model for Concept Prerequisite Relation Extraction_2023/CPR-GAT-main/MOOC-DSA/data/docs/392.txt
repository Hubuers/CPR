Hello, everybody, welcome back to our Flows in Networks unit. Today we're going to be talking an interesting problem on image segmentation. This is a problem in image processing, and we'll actually show that there's some surprising connections to this max-flow min-cut type of things that we've been talking about. So the problem we're trying to solve is image segmentation. Given an image, separate the foreground of the image from the background. And we don't want to get too much into image processing, so here's the basic setup. The image is a grid of pixels. We need to decide which pixels are in the foreground and which are in the background. And I don't know much about how you actually process images, but we're going to assume that there's some other program that gives you some sort of idea about which pixels are in the foreground and which are in the background. So, in particular, there's some other algorithm which looks at each pixel and makes a guess as to whether it's foreground or the background. It assigns this pixel two numbers, av, which is sort of a likelihood that it's in the foreground, and the bv, which is the likelihood that it's in the background. So the simple version of this algorithm, the input are these values a and b, and the output should be a partition of the pixels into foreground and background. So just the sum over v in the foreground of a sub v plus the sum over v in the background of b sub v is as large as possible. So to be sure that we're on the same page, here's a really simple version. We've got three pixels and we've got some a and b values. What's the best possible value that we can get out of this problem? Well, it turns out that this problem is actually not that hard to solve in general. Basically, for any pixel, if you put it in the foreground, you get a points, and if you put it in the background, you get b points. So if a is bigger than b, it goes in the foreground, and if b is bigger than a, it goes in the background. So what you do is, well, 1 should go in the background and gives us 4. 2 goes in the foreground and gives us 5, 3 goes in the foreground and gives us 6. And so the answer is 4 and 5 and 6 is 15. Very well. Now, this problem is maybe a little bit too easy. But let's take a little bit more information into account. We sort of expect that nearby pixels should be on the same side of the foreground-background divide. They're not going to be sort of randomly spattered throughout the picture, they tend to be more or less connected regions. So for each pair of pixels v and w, we're going to introduce a penalty pvw for putting v in the foreground and putting w in the background. So the full problem is the following. As input we take a, b, and p. Again, we want a partition of our pixels into foreground and background. And now we want to maximize the following. The sum of v in the foreground of av and the sum of v in the background of bv, as before. But now we subtract the sum over all pairs, where v is in the foreground and w is in the background, of pvw. And now we want this thing to be as large as possible. Now, before we get into too much depth on this, I'm going to do a tiny bit of algebra. I'm going to subtract the sum over all vertices v, all pixels v, of av plus bv. And the point is that this is a constant that doesn't depend on our foreground-background split, so this doesn't really affect our maximization problem. It just changes the numbers around a bit. We now want to maximize negative the sum over v in the foreground of bv and then v in the background of av, and then pairs v in the foreground w in the background of pvw. Now, instead of maximizing a negative quantity, of course, we can try to minimize this positive quantity. Okay. That changed things around a bit. What do we do now? Well, the thing to note is that we want to split the vertices into two sets. And we pay a cost. And the cost is mostly based on the boundary between these two sets, sort of pairs where we break across the boundary, that's where we pay this big penalty. And this looks like kind of a familiar problem. This looks a lot like a minimum cut problem. So to make this all formal, let's try and build a network so that this is a minimum cut problem. The first thing we have to do is add two new vertices, a source and a sink. Now, we add edges from a source to vertex v with capacity av and an edge from v to t with capacity bv. We also add an edge from v to w with capacity pvw. And this gives us a network. Now, if we have a cut in this network, the cut contains S and not t, and then some of the other pixels and not some of the others. Now, what's the size of this cut? Well, if v's inside our cut, there's an edge from v to T with capacity bv. If v is not in our cut, there's an edge from S to v with capacity av. And then if v is in our cut but w isn't, there's an edge from v to w with capacity pvw. But if you stare at this for a bit, you'll note that if we just let the foreground be this thing is in the cut and the background be the thing is not in the cut, this is exactly the thing that we're trying to minimize. So the original problem of this image segmentation boils down exactly to solving this minimum cut problem. And now, maybe we don't know directly how to solve mincut, but we know that mincut is equal to maxflow. And so we're just going to use our maxflow algorithms. We're going to construct this network, compute the maximum flow, and then find the corresponding minimum cut. So the algorithm for image segmentation is really not that hard. You construct the corresponding network G. You then compute a maxflow f for G using Edmonds-Karp or whatever other algorithm you want. Then we need to find the corresponding flow, so we compute the residual network. And you let C be the collection of vertices reachable from the source in this residual network. Then the foreground should just be the same. C, the background, should be everything else. That is the optimal solution to our image segmentation. And so in summary, we started with this basic problem in image processing, we found a nice mathematical formulation, and then we noted that it looked a lot like minimum cut. And we're able to construct a network, use the relationship between maxflow and mincut, and then use our existing maximum flow algorithm to just solve this problem. And so this is one final application of these flow algorithms that we've been discussing. That's really all that we have to say for the moment about these flows and network algorithms. Come back next time, we'll start another unit on linear programming problems, where we'll discuss some problems that are actually somewhat more general than the ones we've been discussing here that turn out to be very useful in practice. So I hope to see you then. 